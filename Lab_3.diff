diff --git a/Lab_3.diff b/Lab_3.diff
new file mode 100644
index 0000000..e69de29
diff --git a/src/HAL9000/src/Entry64.c b/src/HAL9000/src/Entry64.c
index a9ccc37..095eadd 100644
--- a/src/HAL9000/src/Entry64.c
+++ b/src/HAL9000/src/Entry64.c
@@ -22,8 +22,8 @@ int _fltused = 1;
 void
 Entry64(
     IN  int                 argc,
-    IN  ASM_PARAMETERS*     argv
-    )
+    IN  ASM_PARAMETERS* argv
+)
 {
     STATUS status;
     COMMON_LIB_INIT initSettings;
@@ -60,6 +60,9 @@ Entry64(
     status = SystemInit(argv);
     ASSERT(SUCCEEDED(status));
 
+    LogSetLevel(LogLevelTrace);
+    LogSetTracedComponents(LogComponentThread);
+
     LOGL("InitSystem executed successfully\n");
 
 #ifdef TST
diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
index 6cf5bcc..e588bb4 100644
--- a/src/HAL9000/src/system.c
+++ b/src/HAL9000/src/system.c
@@ -28,7 +28,7 @@ STATIC_ASSERT(NO_OF_TSS_STACKS <= NO_OF_IST);
 typedef struct _SYSTEM_DATA
 {
     BYTE        NumberOfTssStacks;
-} SYSTEM_DATA, *PSYSTEM_DATA;
+} SYSTEM_DATA, * PSYSTEM_DATA;
 
 static SYSTEM_DATA m_systemData;
 
@@ -37,7 +37,7 @@ QWORD gVirtualToPhysicalOffset;
 void
 SystemPreinit(
     void
-    )
+)
 {
     memzero(&m_systemData, sizeof(SYSTEM_DATA));
 
@@ -61,8 +61,8 @@ SystemPreinit(
 
 STATUS
 SystemInit(
-    IN  ASM_PARAMETERS*     Parameters
-    )
+    IN  ASM_PARAMETERS* Parameters
+)
 {
     STATUS status;
     PCPU* pCpu;
@@ -70,10 +70,10 @@ SystemInit(
     status = STATUS_SUCCESS;
     pCpu = NULL;
 
-    LogSystemInit(LogLevelInfo,
-                  LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
-                  TRUE
-                  );
+    LogSystemInit(LogLevelError,
+        LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
+        TRUE
+    );
 
     // if validation fails => the system will HALT
     CpuMuValidateConfiguration();
@@ -101,7 +101,7 @@ SystemInit(
         OsGetBuildType(),
         OsGetVersion(),
         OsGetBuildDate()
-        );
+    );
 
     status = OsInfoInit();
     if (!SUCCEEDED(status))
@@ -134,10 +134,10 @@ SystemInit(
     LOGL("InitIdtHandlers succeeded\n");
 
     status = MmuInitSystem(Parameters->KernelBaseAddress,
-                           (DWORD) Parameters->KernelSize,
-                           Parameters->MemoryMapAddress,
-                           Parameters->MemoryMapEntries
-                           );
+        (DWORD)Parameters->KernelSize,
+        Parameters->MemoryMapAddress,
+        Parameters->MemoryMapEntries
+    );
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("MmuInitSystem", status);
@@ -149,7 +149,7 @@ SystemInit(
     if (IsBooleanFlagOn(Parameters->MultibootInformation->Flags, MULTIBOOT_FLAG_BOOT_MODULES_PRESENT))
     {
         status = BootModulesInit((PHYSICAL_ADDRESS)(QWORD)Parameters->MultibootInformation->ModuleAddress,
-                                Parameters->MultibootInformation->ModuleCount);
+            Parameters->MultibootInformation->ModuleCount);
         if (!SUCCEEDED(status))
         {
             LOG_FUNC_ERROR("BootModulesMap", status);
@@ -195,12 +195,12 @@ SystemInit(
     // this needs to be before the call to IomuInitSystem because
     // by the time we enable interrupts we want our TSS descriptor to be installed
     status = CpuMuAllocAndInitCpu(&pCpu,
-    // C28039: The type of actual parameter 'CpuGetApicId()' should exactly match the type 'APIC_ID'
+        // C28039: The type of actual parameter 'CpuGetApicId()' should exactly match the type 'APIC_ID'
 #pragma warning(suppress: 28039)
-                                  CpuGetApicId(),
-                                  STACK_DEFAULT_SIZE,
-                                  m_systemData.NumberOfTssStacks
-                                  );
+        CpuGetApicId(),
+        STACK_DEFAULT_SIZE,
+        m_systemData.NumberOfTssStacks
+    );
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("CpuMuAllocAndInitCpu", status);
@@ -210,7 +210,7 @@ SystemInit(
 
     // initialize IO system
     // this also initializes the IDT
-    status = IomuInitSystem(GdtMuGetCS64Supervisor(),m_systemData.NumberOfTssStacks );
+    status = IomuInitSystem(GdtMuGetCS64Supervisor(), m_systemData.NumberOfTssStacks);
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("IomuInitSystem", status);
@@ -288,7 +288,7 @@ SystemInit(
     status = MmuInitThreadingSystem();
     if (!SUCCEEDED(status))
     {
-        LOG_FUNC_ERROR("MmuInitThreadingSystem", status );
+        LOG_FUNC_ERROR("MmuInitThreadingSystem", status);
         return status;
     }
 
@@ -319,7 +319,7 @@ SystemInit(
 void
 SystemUninit(
     void
-    )
+)
 {
     LOGL("Finished command execution\n");
 
diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
index 3ec2095..fb1c6a2 100644
--- a/src/HAL9000/src/thread.c
+++ b/src/HAL9000/src/thread.c
@@ -19,7 +19,7 @@ extern void ThreadStart();
 typedef
 void
 (__cdecl FUNC_ThreadSwitch)(
-    OUT_PTR         PVOID*          OldStack,
+    OUT_PTR         PVOID* OldStack,
     IN              PVOID           NewStack
     );
 
@@ -30,13 +30,13 @@ typedef struct _THREAD_SYSTEM_DATA
     LOCK                AllThreadsLock;
 
     _Guarded_by_(AllThreadsLock)
-    LIST_ENTRY          AllThreadsList;
+        LIST_ENTRY          AllThreadsList;
 
     LOCK                ReadyThreadsLock;
 
     _Guarded_by_(ReadyThreadsLock)
-    LIST_ENTRY          ReadyThreadsList;
-} THREAD_SYSTEM_DATA, *PTHREAD_SYSTEM_DATA;
+        LIST_ENTRY          ReadyThreadsList;
+} THREAD_SYSTEM_DATA, * PTHREAD_SYSTEM_DATA;
 
 static THREAD_SYSTEM_DATA m_threadSystemData;
 
@@ -45,7 +45,7 @@ static
 TID
 _ThreadSystemGetNextTid(
     void
-    )
+)
 {
     static volatile TID __currentTid = 0;
 
@@ -55,11 +55,11 @@ _ThreadSystemGetNextTid(
 static
 STATUS
 _ThreadInit(
-    IN_Z        char*               Name,
+    IN_Z        char* Name,
     IN          THREAD_PRIORITY     Priority,
-    OUT_PTR     PTHREAD*            Thread,
+    OUT_PTR     PTHREAD* Thread,
     IN          BOOLEAN             AllocateKernelStack
-    );
+);
 
 static
 STATUS
@@ -69,15 +69,15 @@ _ThreadSetupInitialState(
     IN      QWORD               FirstArgument,
     IN      QWORD               SecondArgument,
     IN      BOOLEAN             KernelStack
-    );
+);
 
 static
 STATUS
 _ThreadSetupMainThreadUserStack(
     IN      PVOID               InitialStack,
-    OUT     PVOID*              ResultingStack,
+    OUT     PVOID* ResultingStack,
     IN      PPROCESS            Process
-    );
+);
 
 
 REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
@@ -86,14 +86,14 @@ static
 void
 _ThreadSchedule(
     void
-    );
+);
 
 REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
 RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_threadSystemData.ReadyThreadsLock)
 void
 ThreadCleanupPostSchedule(
     void
-    );
+);
 
 REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
 static
@@ -101,25 +101,25 @@ _Ret_notnull_
 PTHREAD
 _ThreadGetReadyThread(
     void
-    );
+);
 
 static
 void
 _ThreadForcedExit(
     void
-    );
+);
 
 static
 void
 _ThreadReference(
     INOUT   PTHREAD                 Thread
-    );
+);
 
 static
 void
 _ThreadDereference(
     INOUT   PTHREAD                 Thread
-    );
+);
 
 static FUNC_FreeFunction            _ThreadDestroy;
 
@@ -128,7 +128,7 @@ void
 _ThreadKernelFunction(
     IN      PFUNC_ThreadStart       Function,
     IN_OPT  PVOID                   Context
-    );
+);
 
 static FUNC_ThreadStart     _IdleThread;
 
@@ -136,7 +136,7 @@ void
 _No_competing_thread_
 ThreadSystemPreinit(
     void
-    )
+)
 {
     memzero(&m_threadSystemData, sizeof(THREAD_SYSTEM_DATA));
 
@@ -150,7 +150,7 @@ ThreadSystemPreinit(
 STATUS
 ThreadSystemInitMainForCurrentCPU(
     void
-    )
+)
 {
     STATUS status;
     PPCPU pCpu;
@@ -165,14 +165,22 @@ ThreadSystemInitMainForCurrentCPU(
     pThread = NULL;
     pProcess = ProcessRetrieveSystemProcess();
 
-    ASSERT( NULL != pCpu );
-
-    snprintf( mainThreadName, MAX_PATH, "%s-%02x", "main", pCpu->ApicId );
+    ASSERT(NULL != pCpu);
 
-    status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
+    snprintf(mainThreadName, MAX_PATH, "%s-%02x", "main", pCpu->ApicId);
+
+    /**
+    * The OS crashes because the _ThreadInit function is supposed to initialize the main thread.
+    * The third parameter of the function is the thread to be initialized.
+    * If we are sending a null, we are telling the system to initialize a null thread, so the check
+            ASSERT(NULL != Thread);
+    * found inside _ThreadInit will fail.
+    **/
+    status = _ThreadInit(mainThreadName, ThreadPriorityDefault, NULL, FALSE);
+    //status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
     if (!SUCCEEDED(status))
     {
-        LOG_FUNC_ERROR("_ThreadInit", status );
+        LOG_FUNC_ERROR("_ThreadInit", status);
         return status;
     }
     LOGPL("_ThreadInit succeeded\n");
@@ -199,7 +207,7 @@ ThreadSystemInitMainForCurrentCPU(
 STATUS
 ThreadSystemInitIdleForCurrentCPU(
     void
-    )
+)
 {
     EX_EVENT idleStarted;
     STATUS status;
@@ -207,7 +215,7 @@ ThreadSystemInitIdleForCurrentCPU(
     char idleThreadName[MAX_PATH];
     PTHREAD idleThread;
 
-    ASSERT( INTR_OFF == CpuIntrGetState() );
+    ASSERT(INTR_OFF == CpuIntrGetState());
 
     LOG_FUNC_START_THREAD;
 
@@ -228,11 +236,11 @@ ThreadSystemInitIdleForCurrentCPU(
 
     // create idle thread
     status = ThreadCreate(idleThreadName,
-                          ThreadPriorityDefault,
-                          _IdleThread,
-                          &idleStarted,
-                          &idleThread
-                          );
+        ThreadPriorityDefault,
+        _IdleThread,
+        &idleStarted,
+        &idleThread
+    );
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("ThreadCreate", status);
@@ -240,6 +248,10 @@ ThreadSystemInitIdleForCurrentCPU(
     }
     LOGPL("ThreadCreate for IDLE thread succeeded\n");
 
+    if (pCpu->BspProcessor) {
+        LogSetLevel(LogLevelInfo);
+    }
+
     ThreadCloseHandle(idleThread);
     idleThread = NULL;
 
@@ -262,30 +274,30 @@ ThreadSystemInitIdleForCurrentCPU(
 
 STATUS
 ThreadCreate(
-    IN_Z        char*               Name,
+    IN_Z        char* Name,
     IN          THREAD_PRIORITY     Priority,
     IN          PFUNC_ThreadStart   Function,
     IN_OPT      PVOID               Context,
-    OUT_PTR     PTHREAD*            Thread
-    )
+    OUT_PTR     PTHREAD* Thread
+)
 {
     return ThreadCreateEx(Name,
-                          Priority,
-                          Function,
-                          Context,
-                          Thread,
-                          ProcessRetrieveSystemProcess());
+        Priority,
+        Function,
+        Context,
+        Thread,
+        ProcessRetrieveSystemProcess());
 }
 
 STATUS
 ThreadCreateEx(
-    IN_Z        char*               Name,
+    IN_Z        char* Name,
     IN          THREAD_PRIORITY     Priority,
     IN          PFUNC_ThreadStart   Function,
     IN_OPT      PVOID               Context,
-    OUT_PTR     PTHREAD*            Thread,
-    INOUT       struct _PROCESS*    Process
-    )
+    OUT_PTR     PTHREAD* Thread,
+    INOUT       struct _PROCESS* Process
+)
 {
     STATUS status;
     PTHREAD pThread;
@@ -341,9 +353,9 @@ ThreadCreateEx(
     {
         // Create user-mode stack
         pThread->UserStack = MmuAllocStack(STACK_DEFAULT_SIZE,
-                                           TRUE,
-                                           FALSE,
-                                           Process);
+            TRUE,
+            FALSE,
+            Process);
         if (pThread->UserStack == NULL)
         {
             status = STATUS_MEMORY_CANNOT_BE_COMMITED;
@@ -361,8 +373,8 @@ ThreadCreateEx(
             ASSERT(Process->NumberOfThreads == 1);
 
             status = _ThreadSetupMainThreadUserStack(pThread->UserStack,
-                                                     &pThread->UserStack,
-                                                     Process);
+                &pThread->UserStack,
+                Process);
             if (!SUCCEEDED(status))
             {
                 LOG_FUNC_ERROR("_ThreadSetupUserStack", status);
@@ -371,12 +383,12 @@ ThreadCreateEx(
         }
         else
         {
-            pThread->UserStack = (PVOID) PtrDiff(pThread->UserStack, SHADOW_STACK_SIZE + sizeof(PVOID));
+            pThread->UserStack = (PVOID)PtrDiff(pThread->UserStack, SHADOW_STACK_SIZE + sizeof(PVOID));
         }
 
-        pStartFunction = (PVOID) (bProcessIniialThread ? Process->HeaderInfo->Preferred.AddressOfEntryPoint : Function);
-        firstArg       = (QWORD) (bProcessIniialThread ? Process->NumberOfArguments : (QWORD) Context);
-        secondArg      = (QWORD) (bProcessIniialThread ? PtrOffset(pThread->UserStack, SHADOW_STACK_SIZE + sizeof(PVOID)) : 0);
+        pStartFunction = (PVOID)(bProcessIniialThread ? Process->HeaderInfo->Preferred.AddressOfEntryPoint : Function);
+        firstArg = (QWORD)(bProcessIniialThread ? Process->NumberOfArguments : (QWORD)Context);
+        secondArg = (QWORD)(bProcessIniialThread ? PtrOffset(pThread->UserStack, SHADOW_STACK_SIZE + sizeof(PVOID)) : 0);
     }
     else
     {
@@ -386,15 +398,15 @@ ThreadCreateEx(
 #pragma warning(suppress:4152)
         pStartFunction = _ThreadKernelFunction;
 
-        firstArg =  (QWORD) Function;
-        secondArg = (QWORD) Context;
+        firstArg = (QWORD)Function;
+        secondArg = (QWORD)Context;
     }
 
     status = _ThreadSetupInitialState(pThread,
-                                      pStartFunction,
-                                      firstArg,
-                                      secondArg,
-                                      Process->PagingData->Data.KernelSpace);
+        pStartFunction,
+        firstArg,
+        secondArg,
+        Process->PagingData->Data.KernelSpace);
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("_ThreadSetupInitialState", status);
@@ -421,13 +433,13 @@ ThreadCreateEx(
 void
 ThreadTick(
     void
-    )
+)
 {
     PPCPU pCpu = GetCurrentPcpu();
     PTHREAD pThread = GetCurrentThread();
 
-    ASSERT( INTR_OFF == CpuIntrGetState());
-    ASSERT( NULL != pCpu);
+    ASSERT(INTR_OFF == CpuIntrGetState());
+    ASSERT(NULL != pCpu);
 
     LOG_TRACE_THREAD("Thread tick\n");
     if (pCpu->ThreadData.IdleThread == pThread)
@@ -450,7 +462,7 @@ ThreadTick(
 void
 ThreadYield(
     void
-    )
+)
 {
     INTR_STATE dummyState;
     INTR_STATE oldState;
@@ -458,13 +470,13 @@ ThreadYield(
     PPCPU pCpu;
     BOOLEAN bForcedYield;
 
-    ASSERT( NULL != pThread);
+    ASSERT(NULL != pThread);
 
     oldState = CpuIntrDisable();
 
     pCpu = GetCurrentPcpu();
 
-    ASSERT( NULL != pCpu );
+    ASSERT(NULL != pCpu);
 
     bForcedYield = pCpu->ThreadData.YieldOnInterruptReturn;
     pCpu->ThreadData.YieldOnInterruptReturn = FALSE;
@@ -486,7 +498,7 @@ ThreadYield(
     }
     pThread->State = ThreadStateReady;
     _ThreadSchedule();
-    ASSERT( !LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+    ASSERT(!LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
     LOG_TRACE_THREAD("Returned from _ThreadSchedule\n");
 
     CpuIntrSetState(oldState);
@@ -495,14 +507,14 @@ ThreadYield(
 void
 ThreadBlock(
     void
-    )
+)
 {
     INTR_STATE oldState;
     PTHREAD pCurrentThread;
 
     pCurrentThread = GetCurrentThread();
 
-    ASSERT( INTR_OFF == CpuIntrGetState());
+    ASSERT(INTR_OFF == CpuIntrGetState());
     ASSERT(LockIsOwner(&pCurrentThread->BlockLock));
 
     if (THREAD_FLAG_FORCE_TERMINATE_PENDING == _InterlockedAnd(&pCurrentThread->Flags, MAX_DWORD))
@@ -515,13 +527,13 @@ ThreadBlock(
     pCurrentThread->State = ThreadStateBlocked;
     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &oldState);
     _ThreadSchedule();
-    ASSERT( !LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+    ASSERT(!LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
 }
 
 void
 ThreadUnblock(
     IN      PTHREAD              Thread
-    )
+)
 {
     INTR_STATE oldState;
     INTR_STATE dummyState;
@@ -535,14 +547,14 @@ ThreadUnblock(
     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
     InsertTailList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList);
     Thread->State = ThreadStateReady;
-    LockRelease(&m_threadSystemData.ReadyThreadsLock, dummyState );
+    LockRelease(&m_threadSystemData.ReadyThreadsLock, dummyState);
     LockRelease(&Thread->BlockLock, oldState);
 }
 
 void
 ThreadExit(
     IN      STATUS              ExitStatus
-    )
+)
 {
     PTHREAD pThread;
     INTR_STATE oldState;
@@ -572,7 +584,7 @@ ThreadExit(
 BOOLEAN
 ThreadYieldOnInterrupt(
     void
-    )
+)
 {
     return GetCurrentPcpu()->ThreadData.YieldOnInterruptReturn;
 }
@@ -580,7 +592,7 @@ ThreadYieldOnInterrupt(
 void
 ThreadTakeBlockLock(
     void
-    )
+)
 {
     INTR_STATE dummyState;
 
@@ -590,11 +602,11 @@ ThreadTakeBlockLock(
 void
 ThreadWaitForTermination(
     IN      PTHREAD             Thread,
-    OUT     STATUS*             ExitStatus
-    )
+    OUT     STATUS* ExitStatus
+)
 {
-    ASSERT( NULL != Thread );
-    ASSERT( NULL != ExitStatus);
+    ASSERT(NULL != Thread);
+    ASSERT(NULL != ExitStatus);
 
     ExEventWaitForSignal(&Thread->TerminationEvt);
 
@@ -604,9 +616,9 @@ ThreadWaitForTermination(
 void
 ThreadCloseHandle(
     INOUT   PTHREAD             Thread
-    )
+)
 {
-    ASSERT( NULL != Thread);
+    ASSERT(NULL != Thread);
 
     _ThreadDereference(Thread);
 }
@@ -614,19 +626,19 @@ ThreadCloseHandle(
 void
 ThreadTerminate(
     INOUT   PTHREAD             Thread
-    )
+)
 {
-    ASSERT( NULL != Thread );
+    ASSERT(NULL != Thread);
 
     // it's not a problem if the thread already finished
-    _InterlockedOr(&Thread->Flags, THREAD_FLAG_FORCE_TERMINATE_PENDING );
+    _InterlockedOr(&Thread->Flags, THREAD_FLAG_FORCE_TERMINATE_PENDING);
 }
 
 const
 char*
 ThreadGetName(
     IN_OPT  PTHREAD             Thread
-    )
+)
 {
     PTHREAD pThread = (NULL != Thread) ? Thread : GetCurrentThread();
 
@@ -636,7 +648,7 @@ ThreadGetName(
 TID
 ThreadGetId(
     IN_OPT  PTHREAD             Thread
-    )
+)
 {
     PTHREAD pThread = (NULL != Thread) ? Thread : GetCurrentThread();
 
@@ -646,7 +658,7 @@ ThreadGetId(
 THREAD_PRIORITY
 ThreadGetPriority(
     IN_OPT  PTHREAD             Thread
-    )
+)
 {
     PTHREAD pThread = (NULL != Thread) ? Thread : GetCurrentThread();
 
@@ -656,7 +668,7 @@ ThreadGetPriority(
 void
 ThreadSetPriority(
     IN      THREAD_PRIORITY     NewPriority
-    )
+)
 {
     ASSERT(ThreadPriorityLowest <= NewPriority && NewPriority <= ThreadPriorityMaximum);
 
@@ -667,7 +679,7 @@ STATUS
 ThreadExecuteForEachThreadEntry(
     IN      PFUNC_ListFunction  Function,
     IN_OPT  PVOID               Context
-    )
+)
 {
     STATUS status;
     INTR_STATE oldState;
@@ -681,11 +693,11 @@ ThreadExecuteForEachThreadEntry(
 
     LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
     status = ForEachElementExecute(&m_threadSystemData.AllThreadsList,
-                                   Function,
-                                   Context,
-                                   FALSE
-                                   );
-    LockRelease(&m_threadSystemData.AllThreadsLock, oldState );
+        Function,
+        Context,
+        FALSE
+    );
+    LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
 
     return status;
 }
@@ -693,7 +705,7 @@ ThreadExecuteForEachThreadEntry(
 void
 SetCurrentThread(
     IN      PTHREAD     Thread
-    )
+)
 {
     PPCPU pCpu;
 
@@ -707,18 +719,18 @@ SetCurrentThread(
     {
         pCpu->StackTop = Thread->InitialStackBase;
         pCpu->StackSize = Thread->StackSize;
-        pCpu->Tss.Rsp[0] = (QWORD) Thread->InitialStackBase;
+        pCpu->Tss.Rsp[0] = (QWORD)Thread->InitialStackBase;
     }
 }
 
 static
 STATUS
 _ThreadInit(
-    IN_Z        char*               Name,
+    IN_Z        char* Name,
     IN          THREAD_PRIORITY     Priority,
-    OUT_PTR     PTHREAD*            Thread,
+    OUT_PTR     PTHREAD* Thread,
     IN          BOOLEAN             AllocateKernelStack
-    )
+)
 {
     STATUS status;
     PTHREAD pThread;
@@ -729,9 +741,18 @@ _ThreadInit(
     LOG_FUNC_START;
 
     ASSERT(NULL != Name);
-    ASSERT(NULL != Thread);
+
+    /*
+    * For this method, the system still crashes, but this time it is caught in some exception handler.
+    *
+    * As for which is the beste method... I'd say both options do the same thing, but in a different way.
+    * In my opinion it is important to have the check
+            ASSERT(NULL != Thread);
+    * because this way we can see clearly were and why the program chrashed.
+    */
+    // ASSERT(NULL != Thread);
     ASSERT_INFO(ThreadPriorityLowest <= Priority && Priority <= ThreadPriorityMaximum,
-                "Priority is 0x%x\n", Priority);
+        "Priority is 0x%x\n", Priority);
 
     status = STATUS_SUCCESS;
     pThread = NULL;
@@ -780,10 +801,10 @@ _ThreadInit(
             pThread->StackSize = STACK_DEFAULT_SIZE;
         }
 
-        pThread->Name = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(char)*(nameLen + 1), HEAP_THREAD_TAG, 0);
+        pThread->Name = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(char) * (nameLen + 1), HEAP_THREAD_TAG, 0);
         if (NULL == pThread->Name)
         {
-            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(char)*(nameLen + 1));
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(char) * (nameLen + 1));
             status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
             __leave;
         }
@@ -854,29 +875,29 @@ _ThreadSetupInitialState(
     IN      QWORD               FirstArgument,
     IN      QWORD               SecondArgument,
     IN      BOOLEAN             KernelStack
-    )
+)
 {
     STATUS status;
     PVOID* pStack;
     PCOMPLETE_PROCESSOR_STATE pState;
     PINTERRUPT_STACK pIst;
 
-    ASSERT( NULL != Thread );
-    ASSERT( NULL != StartFunction);
+    ASSERT(NULL != Thread);
+    ASSERT(NULL != StartFunction);
 
     status = STATUS_SUCCESS;
 
-    pStack = (PVOID*) Thread->Stack;
+    pStack = (PVOID*)Thread->Stack;
 
     // The kernel function has to have a shadow space and a dummy RA
-    pStack = pStack - ( 4 + 1 );
+    pStack = pStack - (4 + 1);
 
-    pStack = (PVOID*) PtrDiff(pStack, sizeof(INTERRUPT_STACK));
+    pStack = (PVOID*)PtrDiff(pStack, sizeof(INTERRUPT_STACK));
 
     // setup pseudo-interrupt stack
-    pIst = (PINTERRUPT_STACK) pStack;
+    pIst = (PINTERRUPT_STACK)pStack;
 
-    pIst->Rip = (QWORD) StartFunction;
+    pIst->Rip = (QWORD)StartFunction;
     if (KernelStack)
     {
         pIst->CS = GdtMuGetCS64Supervisor();
@@ -888,7 +909,7 @@ _ThreadSetupInitialState(
         ASSERT(Thread->UserStack != NULL);
 
         pIst->CS = GdtMuGetCS64Usermode() | RING_THREE_PL;
-        pIst->Rsp = (QWORD) Thread->UserStack;
+        pIst->Rsp = (QWORD)Thread->UserStack;
         pIst->SS = GdtMuGetDS64Usermode() | RING_THREE_PL;
     }
 
@@ -898,10 +919,10 @@ _ThreadSetupInitialState(
 
     // warning C4054: 'type cast': from function pointer 'void (__cdecl *)(const PFUNC_ThreadStart,const PVOID)' to data pointer 'PVOID'
 #pragma warning(suppress:4054)
-    *pStack = (PVOID) ThreadStart;
+    * pStack = (PVOID)ThreadStart;
 
-    pStack = (PVOID*) PtrDiff(pStack, sizeof(COMPLETE_PROCESSOR_STATE));
-    pState = (PCOMPLETE_PROCESSOR_STATE) pStack;
+    pStack = (PVOID*)PtrDiff(pStack, sizeof(COMPLETE_PROCESSOR_STATE));
+    pState = (PCOMPLETE_PROCESSOR_STATE)pStack;
 
     memzero(pState, sizeof(COMPLETE_PROCESSOR_STATE));
     pState->RegisterArea.RegisterValues[RegisterRcx] = FirstArgument;
@@ -942,9 +963,9 @@ static
 STATUS
 _ThreadSetupMainThreadUserStack(
     IN      PVOID               InitialStack,
-    OUT     PVOID*              ResultingStack,
+    OUT     PVOID* ResultingStack,
     IN      PPROCESS            Process
-    )
+)
 {
     ASSERT(InitialStack != NULL);
     ASSERT(ResultingStack != NULL);
@@ -961,7 +982,7 @@ static
 void
 _ThreadSchedule(
     void
-    )
+)
 {
     PTHREAD pCurrentThread;
     PTHREAD pNextThread;
@@ -971,7 +992,7 @@ _ThreadSchedule(
     ASSERT(LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
 
     pCurrentThread = GetCurrentThread();
-    ASSERT( NULL != pCurrentThread );
+    ASSERT(NULL != pCurrentThread);
 
     pCpu = GetCurrentPcpu();
 
@@ -980,7 +1001,7 @@ _ThreadSchedule(
 
     // get next thread
     pNextThread = _ThreadGetReadyThread();
-    ASSERT( NULL != pNextThread );
+    ASSERT(NULL != pNextThread);
 
     // if current differs from next
     // => schedule next
@@ -1001,7 +1022,7 @@ _ThreadSchedule(
         pCurrentThread->UninterruptedTicks = 0;
 
         SetCurrentThread(pNextThread);
-        ThreadSwitch( &pCurrentThread->Stack, pNextThread->Stack);
+        ThreadSwitch(&pCurrentThread->Stack, pNextThread->Stack);
 
         ASSERT(INTR_OFF == CpuIntrGetState());
         ASSERT(LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
@@ -1032,7 +1053,7 @@ RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_threadSystemData.ReadyThreadsLock)
 void
 ThreadCleanupPostSchedule(
     void
-    )
+)
 {
     PTHREAD prevThread;
 
@@ -1052,7 +1073,7 @@ ThreadCleanupPostSchedule(
             // it was previously holding the block hold, it may have been preempted before
             // acquiring it.
             ASSERT(prevThread->State == ThreadStateBlocked
-                   || prevThread == GetCurrentPcpu()->ThreadData.IdleThread);
+                || prevThread == GetCurrentPcpu()->ThreadData.IdleThread);
 
             LOG_TRACE_THREAD("Will release block lock for thread [%s]\n", prevThread->Name);
 
@@ -1080,9 +1101,9 @@ STATUS
 
     LOG_FUNC_START_THREAD;
 
-    ASSERT( NULL != Context);
+    ASSERT(NULL != Context);
 
-    pEvent = (PEX_EVENT) Context;
+    pEvent = (PEX_EVENT)Context;
     ExEventSignal(pEvent);
 
     // warning C4127: conditional expression is constant
@@ -1105,14 +1126,14 @@ _Ret_notnull_
 PTHREAD
 _ThreadGetReadyThread(
     void
-    )
+)
 {
     PTHREAD pNextThread;
     PLIST_ENTRY pEntry;
     BOOLEAN bIdleScheduled;
 
-    ASSERT( INTR_OFF == CpuIntrGetState());
-    ASSERT( LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+    ASSERT(INTR_OFF == CpuIntrGetState());
+    ASSERT(LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
 
     pNextThread = NULL;
 
@@ -1124,9 +1145,9 @@ _ThreadGetReadyThread(
     }
     else
     {
-        pNextThread = CONTAINING_RECORD( pEntry, THREAD, ReadyList );
+        pNextThread = CONTAINING_RECORD(pEntry, THREAD, ReadyList);
 
-        ASSERT( pNextThread->State == ThreadStateReady );
+        ASSERT(pNextThread->State == ThreadStateReady);
         bIdleScheduled = FALSE;
     }
 
@@ -1142,11 +1163,11 @@ static
 void
 _ThreadForcedExit(
     void
-    )
+)
 {
     PTHREAD pCurrentThread = GetCurrentThread();
 
-    _InterlockedOr( &pCurrentThread->Flags, THREAD_FLAG_FORCE_TERMINATED );
+    _InterlockedOr(&pCurrentThread->Flags, THREAD_FLAG_FORCE_TERMINATED);
 
     ThreadExit(STATUS_JOB_INTERRUPTED);
     NOT_REACHED;
@@ -1156,9 +1177,9 @@ static
 void
 _ThreadReference(
     INOUT   PTHREAD                 Thread
-    )
+)
 {
-    ASSERT( NULL != Thread );
+    ASSERT(NULL != Thread);
 
     RfcReference(&Thread->RefCnt);
 }
@@ -1167,9 +1188,9 @@ static
 void
 _ThreadDereference(
     INOUT   PTHREAD                 Thread
-    )
+)
 {
-    ASSERT( NULL != Thread );
+    ASSERT(NULL != Thread);
 
     RfcDereference(&Thread->RefCnt);
 }
@@ -1179,10 +1200,10 @@ void
 _ThreadDestroy(
     IN      PVOID                   Object,
     IN_OPT  PVOID                   Context
-    )
+)
 {
     INTR_STATE oldState;
-    PTHREAD pThread = (PTHREAD) CONTAINING_RECORD(Object, THREAD, RefCnt);
+    PTHREAD pThread = (PTHREAD)CONTAINING_RECORD(Object, THREAD, RefCnt);
 
     ASSERT(NULL != pThread);
     ASSERT(NULL == Context);
@@ -1225,7 +1246,7 @@ void
 _ThreadKernelFunction(
     IN      PFUNC_ThreadStart       Function,
     IN_OPT  PVOID                   Context
-    )
+)
 {
     STATUS exitStatus;
 
