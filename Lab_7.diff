diff --git a/Lab_6.diff b/Lab_6.diff
deleted file mode 100644
index 0faf1ee..0000000
--- a/Lab_6.diff
+++ /dev/null
@@ -1,334 +0,0 @@
-diff --git a/Lab_6.diff b/Lab_6.diff
-new file mode 100644
-index 0000000..6cc966e
---- /dev/null
-+++ b/Lab_6.diff
-@@ -0,0 +1,164 @@
-+diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
-+index cec924b..ad3f69a 100644
-+--- a/postbuild/paths.cmd
-++++ b/postbuild/paths.cmd
-+@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
-+ set PATH_TO_VM_TOOLS=__EMPTY__
-+ set VOL_MOUNT_LETTER=__EMPTY__
-+ 
-++if _%COMPUTERNAME%_==_ASUS-LAURA_ goto config_ASUS-LAURA
-+ if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
-+ if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
-+ if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
-+@@ -69,4 +70,15 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
-+ 
-+ goto end
-+ 
-++:config_ASUS-LAURA
-++
-++SET PATH_TO_VM_DISK="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
-++SET PXE_PATH="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\PXE"
-++SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware Workstation"
-++SET VOL_MOUNT_LETTER="Q:"
-++SET PATH_TO_LOG_FILE="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\VM\HAL9000_VM\HAL9000.log"
-++SET PATH_TO_VM_TOOLS="C:\Program Files (x86)\VMware\VMware Virtual Disk Development Kit"
-++SET PATH_TO_VM_FILE="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
-++goto end
-++
-+ :end
-+\ No newline at end of file
-+diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
-+index 1576f7f..f919c9f 100644
-+--- a/src/HAL9000/src/syscall.c
-++++ b/src/HAL9000/src/syscall.c
-+@@ -7,7 +7,28 @@
-+ #include "mmu.h"
-+ #include "process_internal.h"
-+ #include "dmp_cpu.h"
-+-
-++#include "thread.h"
-++
-++/*
-++* Unserstanding user application and system calls
-++* 0. Thay have to be copied because they are not a part of the OS.
-++* 
-++* 1. The UsermodeLibrary represents application’s entry point.
-++* 2.
-++*       STATUS
-++*       __main(
-++*           DWORD       argc,
-++*           char**      argv
-++*           )
-++*       {
-++*/
-++
-++
-++/*
-++* In order to dispatch a Syscall, we use the extern function SyscallEntry
-++* with one parameter being the SysCallId and then a kind of "Context" containing
-++* as many parameters as needed for the syscall.
-++*/
-+ extern void SyscallEntry();
-+ 
-+ #define SYSCALL_IF_VERSION_KM       SYSCALL_IMPLEMENTED_IF_VERSION
-+@@ -68,6 +89,15 @@ SyscallHandler(
-+             status = SyscallValidateInterface((SYSCALL_IF_VERSION)*pSyscallParameters);
-+             break;
-+         // STUDENT TODO: implement the rest of the syscalls
-++        case SyscallIdFileWrite:
-++            status = SyscallFileWrite((UM_HANDLE) pSyscallParameters[0], (PVOID) pSyscallParameters[1], (QWORD) pSyscallParameters[2], NULL);
-++            break;
-++        case SyscallIdProcessExit:
-++            SyscallProcessExit((STATUS)pSyscallParameters[0]);
-++            break;
-++        case SyscallIdThreadExit:
-++            SyscallThreadExit((STATUS)pSyscallParameters[0]);
-++            break;
-+         default:
-+             LOG_ERROR("Unimplemented syscall called from User-space!\n");
-+             status = STATUS_UNSUPPORTED;
-+@@ -169,4 +199,46 @@ SyscallValidateInterface(
-+     return STATUS_SUCCESS;
-+ }
-+ 
-+-// STUDENT TODO: implement the rest of the syscalls
-+\ No newline at end of file
-++// STUDENT TODO: implement the rest of the syscalls
-++STATUS
-++SyscallFileWrite(
-++    IN  UM_HANDLE                   FileHandle,
-++    IN_READS_BYTES(BytesToWrite)
-++    PVOID                       Buffer,
-++    IN  QWORD                       BytesToWrite,
-++    OUT QWORD* BytesWritten
-++) {
-++   UNREFERENCED_PARAMETER(BytesWritten);
-++   UNREFERENCED_PARAMETER(BytesToWrite);
-++   UNREFERENCED_PARAMETER(Buffer);
-++
-++   if (FileHandle == UM_FILE_HANDLE_STDOUT) {
-++       LOG("[%s]:[%s]\n", ProcessGetName(NULL), Buffer);
-++       return STATUS_SUCCESS;
-++   }
-++
-++   return STATUS_NO_HANDLING_REQUIRED;
-++}
-++
-++STATUS
-++SyscallProcessExit(
-++    IN      STATUS                  ExitStatus
-++) {
-++    PPROCESS Process = GetCurrentProcess();
-++    Process->TerminationStatus = ExitStatus;
-++
-++    ProcessTerminate(Process);
-++    LOG("Process has terminated\n");
-++
-++    return STATUS_SUCCESS;
-++}
-++
-++STATUS
-++SyscallThreadExit(
-++    IN  STATUS                      ExitStatus
-++) {
-++    ThreadExit(ExitStatus);
-++    LOG("Thread has exited\n");
-++
-++    return STATUS_SUCCESS;
-++}
-+\ No newline at end of file
-+diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
-+index b0b436e..e802a28 100644
-+--- a/src/HAL9000/src/system.c
-++++ b/src/HAL9000/src/system.c
-+@@ -70,10 +70,8 @@ SystemInit(
-+     status = STATUS_SUCCESS;
-+     pCpu = NULL;
-+ 
-+-    LogSystemInit(LogLevelInfo,
-+-                  LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
-+-                  TRUE
-+-                  );
-++    // 1.
-++    LogSystemInit(LogLevelTrace, LogComponentUserMode, TRUE);
-+ 
-+     // if validation fails => the system will HALT
-+     CpuMuValidateConfiguration();
-+diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
-+index b311f0c..fef07e4 100644
-+--- a/src/HAL9000/src/thread.c
-++++ b/src/HAL9000/src/thread.c
-+@@ -950,7 +950,12 @@ _ThreadSetupMainThreadUserStack(
-+     ASSERT(ResultingStack != NULL);
-+     ASSERT(Process != NULL);
-+ 
-+-    *ResultingStack = InitialStack;
-++    // *ResultingStack = InitialStack;
-++    /* 
-++    * 3. The caller has to reserve space for their callee's shadow space before running a call instruction.
-++    *   This is definetley not the final implementation, but it is a starting point.
-++    */
-++    *ResultingStack = (PVOID)PtrDiff(InitialStack, SHADOW_STACK_SIZE + sizeof(PVOID));
-+ 
-+     return STATUS_SUCCESS;
-+ }
-diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
-index cec924b..ad3f69a 100644
---- a/postbuild/paths.cmd
-+++ b/postbuild/paths.cmd
-@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
- set PATH_TO_VM_TOOLS=__EMPTY__
- set VOL_MOUNT_LETTER=__EMPTY__
- 
-+if _%COMPUTERNAME%_==_ASUS-LAURA_ goto config_ASUS-LAURA
- if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
- if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
- if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
-@@ -69,4 +70,15 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
- 
- goto end
- 
-+:config_ASUS-LAURA
-+
-+SET PATH_TO_VM_DISK="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
-+SET PXE_PATH="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\PXE"
-+SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware Workstation"
-+SET VOL_MOUNT_LETTER="Q:"
-+SET PATH_TO_LOG_FILE="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\VM\HAL9000_VM\HAL9000.log"
-+SET PATH_TO_VM_TOOLS="C:\Program Files (x86)\VMware\VMware Virtual Disk Development Kit"
-+SET PATH_TO_VM_FILE="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
-+goto end
-+
- :end
-\ No newline at end of file
-diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
-index 1576f7f..f919c9f 100644
---- a/src/HAL9000/src/syscall.c
-+++ b/src/HAL9000/src/syscall.c
-@@ -7,7 +7,28 @@
- #include "mmu.h"
- #include "process_internal.h"
- #include "dmp_cpu.h"
--
-+#include "thread.h"
-+
-+/*
-+* Unserstanding user application and system calls
-+* 0. Thay have to be copied because they are not a part of the OS.
-+* 
-+* 1. The UsermodeLibrary represents application’s entry point.
-+* 2.
-+*       STATUS
-+*       __main(
-+*           DWORD       argc,
-+*           char**      argv
-+*           )
-+*       {
-+*/
-+
-+
-+/*
-+* In order to dispatch a Syscall, we use the extern function SyscallEntry
-+* with one parameter being the SysCallId and then a kind of "Context" containing
-+* as many parameters as needed for the syscall.
-+*/
- extern void SyscallEntry();
- 
- #define SYSCALL_IF_VERSION_KM       SYSCALL_IMPLEMENTED_IF_VERSION
-@@ -68,6 +89,15 @@ SyscallHandler(
-             status = SyscallValidateInterface((SYSCALL_IF_VERSION)*pSyscallParameters);
-             break;
-         // STUDENT TODO: implement the rest of the syscalls
-+        case SyscallIdFileWrite:
-+            status = SyscallFileWrite((UM_HANDLE) pSyscallParameters[0], (PVOID) pSyscallParameters[1], (QWORD) pSyscallParameters[2], NULL);
-+            break;
-+        case SyscallIdProcessExit:
-+            SyscallProcessExit((STATUS)pSyscallParameters[0]);
-+            break;
-+        case SyscallIdThreadExit:
-+            SyscallThreadExit((STATUS)pSyscallParameters[0]);
-+            break;
-         default:
-             LOG_ERROR("Unimplemented syscall called from User-space!\n");
-             status = STATUS_UNSUPPORTED;
-@@ -169,4 +199,46 @@ SyscallValidateInterface(
-     return STATUS_SUCCESS;
- }
- 
--// STUDENT TODO: implement the rest of the syscalls
-\ No newline at end of file
-+// STUDENT TODO: implement the rest of the syscalls
-+STATUS
-+SyscallFileWrite(
-+    IN  UM_HANDLE                   FileHandle,
-+    IN_READS_BYTES(BytesToWrite)
-+    PVOID                       Buffer,
-+    IN  QWORD                       BytesToWrite,
-+    OUT QWORD* BytesWritten
-+) {
-+   UNREFERENCED_PARAMETER(BytesWritten);
-+   UNREFERENCED_PARAMETER(BytesToWrite);
-+   UNREFERENCED_PARAMETER(Buffer);
-+
-+   if (FileHandle == UM_FILE_HANDLE_STDOUT) {
-+       LOG("[%s]:[%s]\n", ProcessGetName(NULL), Buffer);
-+       return STATUS_SUCCESS;
-+   }
-+
-+   return STATUS_NO_HANDLING_REQUIRED;
-+}
-+
-+STATUS
-+SyscallProcessExit(
-+    IN      STATUS                  ExitStatus
-+) {
-+    PPROCESS Process = GetCurrentProcess();
-+    Process->TerminationStatus = ExitStatus;
-+
-+    ProcessTerminate(Process);
-+    LOG("Process has terminated\n");
-+
-+    return STATUS_SUCCESS;
-+}
-+
-+STATUS
-+SyscallThreadExit(
-+    IN  STATUS                      ExitStatus
-+) {
-+    ThreadExit(ExitStatus);
-+    LOG("Thread has exited\n");
-+
-+    return STATUS_SUCCESS;
-+}
-\ No newline at end of file
-diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
-index b0b436e..e802a28 100644
---- a/src/HAL9000/src/system.c
-+++ b/src/HAL9000/src/system.c
-@@ -70,10 +70,8 @@ SystemInit(
-     status = STATUS_SUCCESS;
-     pCpu = NULL;
- 
--    LogSystemInit(LogLevelInfo,
--                  LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
--                  TRUE
--                  );
-+    // 1.
-+    LogSystemInit(LogLevelTrace, LogComponentUserMode, TRUE);
- 
-     // if validation fails => the system will HALT
-     CpuMuValidateConfiguration();
-diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
-index b311f0c..fef07e4 100644
---- a/src/HAL9000/src/thread.c
-+++ b/src/HAL9000/src/thread.c
-@@ -950,7 +950,12 @@ _ThreadSetupMainThreadUserStack(
-     ASSERT(ResultingStack != NULL);
-     ASSERT(Process != NULL);
- 
--    *ResultingStack = InitialStack;
-+    // *ResultingStack = InitialStack;
-+    /* 
-+    * 3. The caller has to reserve space for their callee's shadow space before running a call instruction.
-+    *   This is definetley not the final implementation, but it is a starting point.
-+    */
-+    *ResultingStack = (PVOID)PtrDiff(InitialStack, SHADOW_STACK_SIZE + sizeof(PVOID));
- 
-     return STATUS_SUCCESS;
- }
diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
index e802a28..0a600b5 100644
--- a/src/HAL9000/src/system.c
+++ b/src/HAL9000/src/system.c
@@ -71,7 +71,7 @@ SystemInit(
     pCpu = NULL;
 
     // 1.
-    LogSystemInit(LogLevelTrace, LogComponentUserMode, TRUE);
+    LogSystemInit(LogLevelTrace, LogComponentUserMode | LogComponentMmu, TRUE);
 
     // if validation fails => the system will HALT
     CpuMuValidateConfiguration();
diff --git a/src/HAL9000/src/vmm.c b/src/HAL9000/src/vmm.c
index a70a2cb..50bb3bd 100644
--- a/src/HAL9000/src/vmm.c
+++ b/src/HAL9000/src/vmm.c
@@ -243,6 +243,22 @@ VmmMapMemoryEx(
     return pVirtualAddress;
 }
 
+
+/*
+* 3. Different VAs are mapped to the same PAs
+* 
+* LOGS FROM HAL9000.log:
+*   Will map virtual address 0xFFFF85014B869000 to physical address 0x12F000
+*   Will map virtual address 0xFFFF81014004C000 to physical address 0x130000
+*   Will map virtual address 0xFFFF85014B86B000 to physical address 0x12E000
+*   Will map virtual address 0xFFFF85014B86A000 to physical address 0x131000
+*   Will map virtual address 0xFFFF85014B86C000 to physical address 0x12F000
+* 
+* 4. The rights represent PAGE_RIGHTS for riding, writing or executing
+*   #define PAGE_RIGHTS_READ            0
+*   #define PAGE_RIGHTS_WRITE           1
+*   #define PAGE_RIGHTS_EXECUTE         2   
+*/
 void
 VmmMapMemoryInternal(
     IN      PPAGING_DATA            PagingData,
@@ -270,6 +286,17 @@ VmmMapMemoryInternal(
 
     cr3.Raw = (QWORD) PagingData->BasePhysicalAddress;
 
+    /*
+    * 1. From HAL9000.log I saw that there is "one to one" mapping. Meaning that the low part of the BaseAddress will be mapped as the PhysicalAddress
+    */
+    LOG("Will map virtual address 0x%X to physical address 0x%X\n",
+        BaseAddress, PhysicalAddress);
+
+    // 2.
+    if (!_VmIsKernelAddress(BaseAddress)) {
+        LOG("User space:: VA 0x%X ----> PA 0x%X\n", BaseAddress, PhysicalAddress);
+    }
+
     _VmWalkPagingTables(cr3,
                         BaseAddress,
                         Size,
@@ -373,6 +400,11 @@ VmmPreparePagingData(
     return STATUS_SUCCESS;
 }
 
+/*
+* 5. This function prepares the structures required for managing the paging tables.
+*   Each user application will be mapped through this tables so this will be called with each
+*   new user application.
+*/
 STATUS
 VmmSetupPageTables(
     INOUT   PPAGING_DATA            PagingDataWhereToMap,
@@ -401,9 +433,9 @@ VmmSetupPageTables(
     PagingData->BasePhysicalAddress = BasePhysicalAddress;
     PagingData->KernelSpace = KernelStructures;
 
-    LOG_TRACE_VMM("Will setup paging tables at physical address: 0x%X\n", PagingData->BasePhysicalAddress);
-    LOG_TRACE_VMM("BaseAddress: 0x%X\n", pBaseVirtualAddress);
-    LOG_TRACE_VMM("Size of paging tables: 0x%x\n", sizeReservedForPagingStructures);
+    LOG("Will setup paging tables at physical address: 0x%X\n", PagingData->BasePhysicalAddress);
+    LOG("BaseAddress: 0x%X\n", pBaseVirtualAddress);
+    LOG("Size of paging tables: 0x%x\n", sizeReservedForPagingStructures);
 
     // 1. We cannot zero the memory before mapping it (because it's not mapped)
     // 2. We cannot zero it after it was mapped because we already have some entries
@@ -420,7 +452,7 @@ VmmSetupPageTables(
                          TRUE,
                          FALSE
                          );
-    LOG_TRACE_VMM("VmmMapMemoryInternal finished\n");
+    LOG("VmmMapMemoryInternal finished\n");
 
     if (PagingDataWhereToMap != PagingData)
     {
