diff --git a/Lab_6.diff b/Lab_6.diff
new file mode 100644
index 0000000..6cc966e
--- /dev/null
+++ b/Lab_6.diff
@@ -0,0 +1,164 @@
+diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
+index cec924b..ad3f69a 100644
+--- a/postbuild/paths.cmd
++++ b/postbuild/paths.cmd
+@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
+ set PATH_TO_VM_TOOLS=__EMPTY__
+ set VOL_MOUNT_LETTER=__EMPTY__
+ 
++if _%COMPUTERNAME%_==_ASUS-LAURA_ goto config_ASUS-LAURA
+ if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
+ if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
+ if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
+@@ -69,4 +70,15 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
+ 
+ goto end
+ 
++:config_ASUS-LAURA
++
++SET PATH_TO_VM_DISK="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
++SET PXE_PATH="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\PXE"
++SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware Workstation"
++SET VOL_MOUNT_LETTER="Q:"
++SET PATH_TO_LOG_FILE="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\VM\HAL9000_VM\HAL9000.log"
++SET PATH_TO_VM_TOOLS="C:\Program Files (x86)\VMware\VMware Virtual Disk Development Kit"
++SET PATH_TO_VM_FILE="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
++goto end
++
+ :end
+\ No newline at end of file
+diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
+index 1576f7f..f919c9f 100644
+--- a/src/HAL9000/src/syscall.c
++++ b/src/HAL9000/src/syscall.c
+@@ -7,7 +7,28 @@
+ #include "mmu.h"
+ #include "process_internal.h"
+ #include "dmp_cpu.h"
+-
++#include "thread.h"
++
++/*
++* Unserstanding user application and system calls
++* 0. Thay have to be copied because they are not a part of the OS.
++* 
++* 1. The UsermodeLibrary represents application’s entry point.
++* 2.
++*       STATUS
++*       __main(
++*           DWORD       argc,
++*           char**      argv
++*           )
++*       {
++*/
++
++
++/*
++* In order to dispatch a Syscall, we use the extern function SyscallEntry
++* with one parameter being the SysCallId and then a kind of "Context" containing
++* as many parameters as needed for the syscall.
++*/
+ extern void SyscallEntry();
+ 
+ #define SYSCALL_IF_VERSION_KM       SYSCALL_IMPLEMENTED_IF_VERSION
+@@ -68,6 +89,15 @@ SyscallHandler(
+             status = SyscallValidateInterface((SYSCALL_IF_VERSION)*pSyscallParameters);
+             break;
+         // STUDENT TODO: implement the rest of the syscalls
++        case SyscallIdFileWrite:
++            status = SyscallFileWrite((UM_HANDLE) pSyscallParameters[0], (PVOID) pSyscallParameters[1], (QWORD) pSyscallParameters[2], NULL);
++            break;
++        case SyscallIdProcessExit:
++            SyscallProcessExit((STATUS)pSyscallParameters[0]);
++            break;
++        case SyscallIdThreadExit:
++            SyscallThreadExit((STATUS)pSyscallParameters[0]);
++            break;
+         default:
+             LOG_ERROR("Unimplemented syscall called from User-space!\n");
+             status = STATUS_UNSUPPORTED;
+@@ -169,4 +199,46 @@ SyscallValidateInterface(
+     return STATUS_SUCCESS;
+ }
+ 
+-// STUDENT TODO: implement the rest of the syscalls
+\ No newline at end of file
++// STUDENT TODO: implement the rest of the syscalls
++STATUS
++SyscallFileWrite(
++    IN  UM_HANDLE                   FileHandle,
++    IN_READS_BYTES(BytesToWrite)
++    PVOID                       Buffer,
++    IN  QWORD                       BytesToWrite,
++    OUT QWORD* BytesWritten
++) {
++   UNREFERENCED_PARAMETER(BytesWritten);
++   UNREFERENCED_PARAMETER(BytesToWrite);
++   UNREFERENCED_PARAMETER(Buffer);
++
++   if (FileHandle == UM_FILE_HANDLE_STDOUT) {
++       LOG("[%s]:[%s]\n", ProcessGetName(NULL), Buffer);
++       return STATUS_SUCCESS;
++   }
++
++   return STATUS_NO_HANDLING_REQUIRED;
++}
++
++STATUS
++SyscallProcessExit(
++    IN      STATUS                  ExitStatus
++) {
++    PPROCESS Process = GetCurrentProcess();
++    Process->TerminationStatus = ExitStatus;
++
++    ProcessTerminate(Process);
++    LOG("Process has terminated\n");
++
++    return STATUS_SUCCESS;
++}
++
++STATUS
++SyscallThreadExit(
++    IN  STATUS                      ExitStatus
++) {
++    ThreadExit(ExitStatus);
++    LOG("Thread has exited\n");
++
++    return STATUS_SUCCESS;
++}
+\ No newline at end of file
+diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
+index b0b436e..e802a28 100644
+--- a/src/HAL9000/src/system.c
++++ b/src/HAL9000/src/system.c
+@@ -70,10 +70,8 @@ SystemInit(
+     status = STATUS_SUCCESS;
+     pCpu = NULL;
+ 
+-    LogSystemInit(LogLevelInfo,
+-                  LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
+-                  TRUE
+-                  );
++    // 1.
++    LogSystemInit(LogLevelTrace, LogComponentUserMode, TRUE);
+ 
+     // if validation fails => the system will HALT
+     CpuMuValidateConfiguration();
+diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
+index b311f0c..fef07e4 100644
+--- a/src/HAL9000/src/thread.c
++++ b/src/HAL9000/src/thread.c
+@@ -950,7 +950,12 @@ _ThreadSetupMainThreadUserStack(
+     ASSERT(ResultingStack != NULL);
+     ASSERT(Process != NULL);
+ 
+-    *ResultingStack = InitialStack;
++    // *ResultingStack = InitialStack;
++    /* 
++    * 3. The caller has to reserve space for their callee's shadow space before running a call instruction.
++    *   This is definetley not the final implementation, but it is a starting point.
++    */
++    *ResultingStack = (PVOID)PtrDiff(InitialStack, SHADOW_STACK_SIZE + sizeof(PVOID));
+ 
+     return STATUS_SUCCESS;
+ }
diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
index cec924b..ad3f69a 100644
--- a/postbuild/paths.cmd
+++ b/postbuild/paths.cmd
@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
 set PATH_TO_VM_TOOLS=__EMPTY__
 set VOL_MOUNT_LETTER=__EMPTY__
 
+if _%COMPUTERNAME%_==_ASUS-LAURA_ goto config_ASUS-LAURA
 if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
 if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
 if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
@@ -69,4 +70,15 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
 
 goto end
 
+:config_ASUS-LAURA
+
+SET PATH_TO_VM_DISK="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
+SET PXE_PATH="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\PXE"
+SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware Workstation"
+SET VOL_MOUNT_LETTER="Q:"
+SET PATH_TO_LOG_FILE="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\VM\HAL9000_VM\HAL9000.log"
+SET PATH_TO_VM_TOOLS="C:\Program Files (x86)\VMware\VMware Virtual Disk Development Kit"
+SET PATH_TO_VM_FILE="D:\Facultate\An4_Sem1\OSD\HAL_9000\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
+goto end
+
 :end
\ No newline at end of file
diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
index 1576f7f..f919c9f 100644
--- a/src/HAL9000/src/syscall.c
+++ b/src/HAL9000/src/syscall.c
@@ -7,7 +7,28 @@
 #include "mmu.h"
 #include "process_internal.h"
 #include "dmp_cpu.h"
-
+#include "thread.h"
+
+/*
+* Unserstanding user application and system calls
+* 0. Thay have to be copied because they are not a part of the OS.
+* 
+* 1. The UsermodeLibrary represents application’s entry point.
+* 2.
+*       STATUS
+*       __main(
+*           DWORD       argc,
+*           char**      argv
+*           )
+*       {
+*/
+
+
+/*
+* In order to dispatch a Syscall, we use the extern function SyscallEntry
+* with one parameter being the SysCallId and then a kind of "Context" containing
+* as many parameters as needed for the syscall.
+*/
 extern void SyscallEntry();
 
 #define SYSCALL_IF_VERSION_KM       SYSCALL_IMPLEMENTED_IF_VERSION
@@ -68,6 +89,15 @@ SyscallHandler(
             status = SyscallValidateInterface((SYSCALL_IF_VERSION)*pSyscallParameters);
             break;
         // STUDENT TODO: implement the rest of the syscalls
+        case SyscallIdFileWrite:
+            status = SyscallFileWrite((UM_HANDLE) pSyscallParameters[0], (PVOID) pSyscallParameters[1], (QWORD) pSyscallParameters[2], NULL);
+            break;
+        case SyscallIdProcessExit:
+            SyscallProcessExit((STATUS)pSyscallParameters[0]);
+            break;
+        case SyscallIdThreadExit:
+            SyscallThreadExit((STATUS)pSyscallParameters[0]);
+            break;
         default:
             LOG_ERROR("Unimplemented syscall called from User-space!\n");
             status = STATUS_UNSUPPORTED;
@@ -169,4 +199,46 @@ SyscallValidateInterface(
     return STATUS_SUCCESS;
 }
 
-// STUDENT TODO: implement the rest of the syscalls
\ No newline at end of file
+// STUDENT TODO: implement the rest of the syscalls
+STATUS
+SyscallFileWrite(
+    IN  UM_HANDLE                   FileHandle,
+    IN_READS_BYTES(BytesToWrite)
+    PVOID                       Buffer,
+    IN  QWORD                       BytesToWrite,
+    OUT QWORD* BytesWritten
+) {
+   UNREFERENCED_PARAMETER(BytesWritten);
+   UNREFERENCED_PARAMETER(BytesToWrite);
+   UNREFERENCED_PARAMETER(Buffer);
+
+   if (FileHandle == UM_FILE_HANDLE_STDOUT) {
+       LOG("[%s]:[%s]\n", ProcessGetName(NULL), Buffer);
+       return STATUS_SUCCESS;
+   }
+
+   return STATUS_NO_HANDLING_REQUIRED;
+}
+
+STATUS
+SyscallProcessExit(
+    IN      STATUS                  ExitStatus
+) {
+    PPROCESS Process = GetCurrentProcess();
+    Process->TerminationStatus = ExitStatus;
+
+    ProcessTerminate(Process);
+    LOG("Process has terminated\n");
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+SyscallThreadExit(
+    IN  STATUS                      ExitStatus
+) {
+    ThreadExit(ExitStatus);
+    LOG("Thread has exited\n");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
index b0b436e..e802a28 100644
--- a/src/HAL9000/src/system.c
+++ b/src/HAL9000/src/system.c
@@ -70,10 +70,8 @@ SystemInit(
     status = STATUS_SUCCESS;
     pCpu = NULL;
 
-    LogSystemInit(LogLevelInfo,
-                  LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
-                  TRUE
-                  );
+    // 1.
+    LogSystemInit(LogLevelTrace, LogComponentUserMode, TRUE);
 
     // if validation fails => the system will HALT
     CpuMuValidateConfiguration();
diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
index b311f0c..fef07e4 100644
--- a/src/HAL9000/src/thread.c
+++ b/src/HAL9000/src/thread.c
@@ -950,7 +950,12 @@ _ThreadSetupMainThreadUserStack(
     ASSERT(ResultingStack != NULL);
     ASSERT(Process != NULL);
 
-    *ResultingStack = InitialStack;
+    // *ResultingStack = InitialStack;
+    /* 
+    * 3. The caller has to reserve space for their callee's shadow space before running a call instruction.
+    *   This is definetley not the final implementation, but it is a starting point.
+    */
+    *ResultingStack = (PVOID)PtrDiff(InitialStack, SHADOW_STACK_SIZE + sizeof(PVOID));
 
     return STATUS_SUCCESS;
 }
